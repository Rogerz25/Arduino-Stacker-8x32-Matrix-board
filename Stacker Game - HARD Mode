#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>

// ================== DISPLAY SETUP ==================
#define MAX_DEVICES 4
#define DATA_PIN 8
#define CS_PIN 9
#define CLK_PIN 11

MD_Parola display = MD_Parola(MD_MAX72XX::FC16_HW, DATA_PIN, CLK_PIN, CS_PIN, MAX_DEVICES);

// ================== PASSIVE BUZZER ==================
#define BUTTON_PIN 2
#define BUZZER_PIN 3

// ================== GRID ==================
#define WIDTH 8
#define HEIGHT 32

// ================== GAME VARIABLES ==================
int blockPos = 0;
int blockWidth = 4;
int blockRow = 0;
bool blockMoving = true;
int stack[HEIGHT][WIDTH];
bool gameOverFlag = false;
unsigned long lastMove = 0;
int moveDelay = 220;
bool moveRight = true;
int lastBlockPos = -1;  // tracks previous block position for partial redraw

// ================== SETUP ==================
void setup() {
  Serial.begin(9600);

  display.begin();
  display.setIntensity(5);
  display.displayClear();

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUZZER_PIN, OUTPUT);

  randomSeed(analogRead(A0));
  resetGame();
}

// ================== RESET GAME ==================
void resetGame() {
  for (int r = 0; r < HEIGHT; r++)
    for (int c = 0; c < WIDTH; c++)
      stack[r][c] = 0;

  blockRow = 0;
  blockMoving = true;
  gameOverFlag = false;
  moveDelay = 220;
  moveRight = true;
  lastBlockPos = -1;

  blockWidth = 4;
  blockPos = random(0, WIDTH - blockWidth + 1);

  drawFullGame();  // full redraw only on reset
}

// ================== SPEED INCREASE ==================
void updateSpeed() {
  if (blockRow < 8) moveDelay = 200;
  else if (blockRow < 16) moveDelay = 160;
  else if (blockRow < 24) moveDelay = 140;
  else moveDelay = 100;
}

// ================== FULL REDRAW (reset/init only) ==================
void drawFullGame() {
  display.displayClear();

  for (int r = 0; r < HEIGHT; r++)
    for (int c = 0; c < WIDTH; c++)
      if (stack[r][c])
        display.getGraphicObject()->setPoint(c, r, true);

  if (!gameOverFlag && blockMoving)
    for (int c = blockPos; c < blockPos + blockWidth; c++)
      display.getGraphicObject()->setPoint(c, blockRow, true);

  display.displayAnimate();
  lastBlockPos = blockPos;
}

// ================== DRAW CURRENT ROW ONLY (during movement) ==================
void drawCurrentRow() {
  // Erase previous block position on this row
  if (lastBlockPos >= 0) {
    for (int c = lastBlockPos; c < lastBlockPos + blockWidth + 1; c++) {
      if (c >= 0 && c < WIDTH)
        display.getGraphicObject()->setPoint(c, blockRow, false);
    }
  }

  // Draw new block position
  for (int c = blockPos; c < blockPos + blockWidth; c++) {
    if (c >= 0 && c < WIDTH)
      display.getGraphicObject()->setPoint(c, blockRow, true);
  }

  lastBlockPos = blockPos;
  display.displayAnimate();
}

// ================== COMMIT STACK ROW (after drop) ==================
void drawStackRow(int row) {
  for (int c = 0; c < WIDTH; c++) {
    display.getGraphicObject()->setPoint(c, row, stack[row][c] ? true : false);
  }
}

// ================== SCROLL GAME OVER ==================
void showGameOver() {
  display.displayClear();
  display.displayText(" GAME OVER LOSER!", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  while (!display.displayAnimate());
}

// ================== SCROLL WINNER ==================
void showWinner() {
  display.displayClear();
  display.displayText(" WINNER!!", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  tone(BUZZER_PIN, 1000, 200);
  delay(250);
  tone(BUZZER_PIN, 1200, 200);
  delay(250);
  tone(BUZZER_PIN, 1500, 400);

  while (!display.displayAnimate());
}

// ================== DROP BLOCK ==================
void dropBlock() {
  blockMoving = false;

  int module = blockRow / 8;

  if (module == 0) blockWidth = 4;
  else if (module == 1) blockWidth = 3;
  else if (module == 2) blockWidth = 2;
  else blockWidth = 1;

  int overlap = 0;
  int prevRow = blockRow - 1;
  bool perfect = true;

  for (int c = blockPos; c < blockPos + blockWidth; c++) {
    if (prevRow < 0 || stack[prevRow][c]) {
      stack[blockRow][c] = 1;
      overlap++;
    } else {
      perfect = false;
    }
  }

  int required = blockWidth;
  if (blockWidth >= 3 && prevRow >= 0)
    required = blockWidth - 1;

  if (!perfect && overlap < required) {
    gameOverFlag = true;

    tone(BUZZER_PIN, 400, 300);
    delay(350);
    tone(BUZZER_PIN, 250, 600);
    delay(650);

    showGameOver();
    return;
  }

  if (perfect) overlap = blockWidth;
  blockWidth = overlap;

  // Commit this row to the display permanently
  drawStackRow(blockRow);
  display.displayAnimate();

  tone(BUZZER_PIN, 1000, 100);

  blockRow++;
  updateSpeed();

  if (blockRow >= HEIGHT) {
    gameOverFlag = true;
    showWinner();
    return;
  }

  blockPos = random(0, WIDTH - blockWidth + 1);
  lastBlockPos = -1;  // reset so drawCurrentRow erases cleanly
  blockMoving = true;
  drawCurrentRow();   // only draw the new row, not the whole grid
}

// ================== MAIN LOOP ==================
void loop() {

  if (gameOverFlag) {
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(200);
      resetGame();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
    return;
  }

  if (blockMoving && millis() - lastMove >= moveDelay) {
    blockPos += moveRight ? 1 : -1;

    if (blockPos <= 0) moveRight = true;
    if (blockPos >= WIDTH - blockWidth) moveRight = false;

    lastMove = millis();
    drawCurrentRow();  // only update current row
  }

  if (digitalRead(BUTTON_PIN) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_PIN) == LOW) {
      dropBlock();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
  }
}
