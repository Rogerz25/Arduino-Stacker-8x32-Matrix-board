#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>

// ================== DISPLAY SETUP ==================
#define MAX_DEVICES 4 //# of PANELS 
#define DATA_PIN 8    //DIN
#define CS_PIN 9      //CS
#define CLK_PIN 11    //CLK


MD_Parola display = MD_Parola(MD_MAX72XX::FC16_HW, DATA_PIN, CLK_PIN, CS_PIN, MAX_DEVICES);

// ================== INPUT / SOUND ==================
#define BUTTON_PIN 2
#define BUZZER_PIN 3

// ================== GRID ==================
#define WIDTH 8
#define HEIGHT 32

// ================== GAME VARIABLES ==================
int blockPos = 0;
int blockWidth = 4;
int blockRow = 0;
bool blockMoving = true;
int stack[HEIGHT][WIDTH];
bool gameOverFlag = false;
unsigned long lastMove = 0;
int moveDelay = 220;
bool moveRight = true;

// ================== SETUP ==================
void setup() {
  display.begin();
  display.setIntensity(5);
  display.displayClear();

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUZZER_PIN, OUTPUT);

  randomSeed(analogRead(A0));
  resetGame();
}

// ================== RESET GAME ==================
void resetGame() {
  for (int r = 0; r < HEIGHT; r++)
    for (int c = 0; c < WIDTH; c++)
      stack[r][c] = 0;

  blockRow = 0;
  blockWidth = 4;
  blockMoving = true;
  gameOverFlag = false;
  moveDelay = 220;
  moveRight = true;

  blockPos = random(0, WIDTH - blockWidth + 1);

  drawGame();
}

// ================== SPEED INCREASE ==================
void updateSpeed() {
  if (blockRow < 8) moveDelay = 190;
  else if (blockRow < 16) moveDelay = 160;
  else if (blockRow < 24) moveDelay = 130;
  else moveDelay = 100;
}

// ================== DRAW GAME ==================
void drawGame() {
  display.displayClear();

  for (int r = 0; r < HEIGHT; r++) {
    for (int c = 0; c < WIDTH; c++) {
      if (stack[r][c]) {
        display.getGraphicObject()->setPoint(c, r, true);
      }
    }
  }

  if (!gameOverFlag && blockMoving) {
    for (int c = blockPos; c < blockPos + blockWidth; c++) {
      display.getGraphicObject()->setPoint(c, blockRow, true);
    }
  }

  display.displayAnimate();
}

// ================== GAME OVER ==================
void showGameOver() {
  display.displayClear();
  display.displayText(" GAME OVER! ", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  tone(BUZZER_PIN, 400, 300);
  delay(350);
  tone(BUZZER_PIN, 250, 600);
  delay(650);

  while (!display.displayAnimate());
}

// ================== WINNER ==================
void showWinner() {
  display.displayClear();
  display.displayText("WINNER! ", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  tone(BUZZER_PIN, 1000, 200);
  delay(250);
  tone(BUZZER_PIN, 1200, 200);
  delay(250);
  tone(BUZZER_PIN, 1500, 400);

  while (!display.displayAnimate());
}

// ================== DROP BLOCK ==================
void dropBlock() {
  blockMoving = false;

  int overlap = 0;
  int prevRow = blockRow - 1;

  // First row stays full width
  if (prevRow < 0) {
    for (int c = blockPos; c < blockPos + blockWidth; c++)
      stack[blockRow][c] = 1;
  }
  else {
    // Check overlap
    for (int c = blockPos; c < blockPos + blockWidth; c++) {
      if (stack[prevRow][c]) {
        stack[blockRow][c] = 1;
        overlap++;
      }
    }

    // No overlap = GAME OVER
    if (overlap == 0) {
      gameOverFlag = true;
      showGameOver();
      return;
    }

    // Cut off misaligned parts
    blockWidth = overlap;
  }

  tone(BUZZER_PIN, 1000, 100);

  blockRow++;
  updateSpeed();

  // WIN CONDITION
  if (blockRow >= HEIGHT) {
    gameOverFlag = true;
    showWinner();
    return;
  }

  // Align next block with current stack
  for (int c = 0; c < WIDTH; c++) {
    if (stack[blockRow - 1][c]) {
      blockPos = c;
      break;
    }
  }

  blockMoving = true;
  drawGame();
}

// ================== MAIN LOOP ==================
void loop() {

  if (gameOverFlag) {
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(200);
      resetGame();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
    return;
  }

  // Move block
  if (blockMoving && millis() - lastMove >= moveDelay) {
    blockPos += moveRight ? 1 : -1;

    if (blockPos <= 0) moveRight = true;
    if (blockPos >= WIDTH - blockWidth) moveRight = false;

    lastMove = millis();
    drawGame();
  }

  // Drop block
  if (digitalRead(BUTTON_PIN) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_PIN) == LOW) {
      dropBlock();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
  }
}
