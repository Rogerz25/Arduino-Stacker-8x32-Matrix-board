#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>

// ================== DISPLAY SETUP ==================
#define MAX_DEVICES 4
#define DATA_PIN 8
#define CS_PIN 9
#define CLK_PIN 11

MD_Parola display = MD_Parola(MD_MAX72XX::FC16_HW, DATA_PIN, CLK_PIN, CS_PIN, MAX_DEVICES);

// ================== INPUT / SOUND ==================
#define BUTTON_PIN 2
#define BUZZER_PIN 3

// ================== GRID ==================
#define WIDTH 8
#define HEIGHT 32

// ================== GAME VARIABLES ==================
int blockPos = 0;     //STARTING POSITION
int blockWidth = 4;  //STARTING WITH 4 LEDS DOTS
int blockRow = 0;
bool blockMoving = true;
int stack[HEIGHT][WIDTH];
bool gameOverFlag = false;
unsigned long lastMove = 0;
int moveDelay = 220;
bool moveRight = true;
int lastBlockPos = -1;  // tracks previous block position for partial redraw

// ================== SETUP ==================
void setup() {
  display.begin();
  display.setIntensity(5);
  display.displayClear();

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUZZER_PIN, OUTPUT);

  randomSeed(analogRead(A0));
  resetGame();
}

// ================== RESET GAME ==================
void resetGame() {
  for (int r = 0; r < HEIGHT; r++)
    for (int c = 0; c < WIDTH; c++)
      stack[r][c] = 0;

  blockRow = 0;
  blockWidth = 4;
  blockMoving = true;
  gameOverFlag = false;
  moveDelay = 220;
  moveRight = true;
  lastBlockPos = -1;

  blockPos = random(0, WIDTH - blockWidth + 1);

  drawFullGame();  // full redraw only on reset
}

// ================== SPEED INCREASE ==================
void updateSpeed() {
  if (blockRow < 8) moveDelay = 160;
  else if (blockRow < 16) moveDelay = 140;
  else if (blockRow < 24) moveDelay = 120;
  else moveDelay = 100;
}

// ================== FULL REDRAW (reset/init only) ==================
void drawFullGame() {
  display.displayClear();

  for (int r = 0; r < HEIGHT; r++)
    for (int c = 0; c < WIDTH; c++)
      if (stack[r][c])
        display.getGraphicObject()->setPoint(c, r, true);

  if (!gameOverFlag && blockMoving)
    for (int c = blockPos; c < blockPos + blockWidth; c++)
      display.getGraphicObject()->setPoint(c, blockRow, true);

  display.displayAnimate();
  lastBlockPos = blockPos;
}

// ================== DRAW CURRENT ROW ONLY (during movement) ==================
void drawCurrentRow() {
  // Erase previous block position on this row
  if (lastBlockPos >= 0) {
    for (int c = lastBlockPos; c < lastBlockPos + blockWidth + 1; c++) {
      if (c >= 0 && c < WIDTH)
        display.getGraphicObject()->setPoint(c, blockRow, false);
    }
  }

  // Draw new block position
  for (int c = blockPos; c < blockPos + blockWidth; c++) {
    if (c >= 0 && c < WIDTH)
      display.getGraphicObject()->setPoint(c, blockRow, true);
  }

  lastBlockPos = blockPos;
  display.displayAnimate();
}

// ================== COMMIT STACK ROW (after drop) ==================
void drawStackRow(int row) {
  for (int c = 0; c < WIDTH; c++) {
    display.getGraphicObject()->setPoint(c, row, stack[row][c] ? true : false);
  }
}

// ================== FALLING ANIMATION (cut pieces) ==================
void animateFalling(int startCol[], int count) {
  for (int step = 0; step < 6; step++) {
    // Erase previous falling positions
    if (step > 0) {
      for (int i = 0; i < count; i++) {
        int prevRow = blockRow + step - 1;
        if (prevRow < HEIGHT)
          display.getGraphicObject()->setPoint(startCol[i], prevRow, false);
      }
    }

    // Draw new falling positions
    for (int i = 0; i < count; i++) {
      int fallRow = blockRow + step;
      if (fallRow < HEIGHT)
        display.getGraphicObject()->setPoint(startCol[i], fallRow, true);
    }

    display.displayAnimate();
    delay(50);
  }

  // Erase final falling position
  for (int i = 0; i < count; i++) {
    int finalRow = blockRow + 5;
    if (finalRow < HEIGHT)
      display.getGraphicObject()->setPoint(startCol[i], finalRow, false);
  }
  display.displayAnimate();
}

// ================== GAME OVER ==================
void showGameOver() {
  display.displayClear();
  display.displayText(" GAME OVER LOSER!", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  tone(BUZZER_PIN, 400, 300);
  delay(350);
  tone(BUZZER_PIN, 250, 600);
  delay(650);

  while (!display.displayAnimate());
}

// ================== WINNER ==================
void showWinner() {
  display.displayClear();
  display.displayText(" HUH..YOU ACTUALLY WON!", PA_CENTER, 50, 2000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);

  tone(BUZZER_PIN, 1000, 200);
  delay(250);
  tone(BUZZER_PIN, 1200, 200);
  delay(250);
  tone(BUZZER_PIN, 1500, 400);

  while (!display.displayAnimate());
}

// ================== DROP BLOCK ==================
void dropBlock() {
  blockMoving = false;

  int overlap = 0;
  int prevRow = blockRow - 1;
  int cutCols[4];
  int cutCount = 0;

  if (prevRow < 0) {
    // First row â€” just lock it in
    for (int c = blockPos; c < blockPos + blockWidth; c++)
      stack[blockRow][c] = 1;
  } else {
    for (int c = blockPos; c < blockPos + blockWidth; c++) {
      if (stack[prevRow][c]) {
        stack[blockRow][c] = 1;
        overlap++;
      } else {
        cutCols[cutCount++] = c;
      }
    }

    if (overlap == 0) {
      gameOverFlag = true;
      showGameOver();
      return;
    }

    if (cutCount > 0) {
      animateFalling(cutCols, cutCount);
    }

    blockWidth = overlap;
  }

  // Commit current row to display
  drawStackRow(blockRow);
  display.displayAnimate();

  tone(BUZZER_PIN, 1000, 100);

  blockRow++;
  updateSpeed();

  if (blockRow >= HEIGHT) {
    gameOverFlag = true;
    showWinner();
    return;
  }

  // Start new block aligned to stack below
  for (int c = 0; c < WIDTH; c++) {
    if (stack[blockRow - 1][c]) {
      blockPos = c;
      break;
    }
  }

  lastBlockPos = -1;  // reset so drawCurrentRow erases cleanly from scratch
  blockMoving = true;
  drawCurrentRow();   // draw only the new row, not the whole grid
}

// ================== MAIN LOOP ==================
void loop() {

  if (gameOverFlag) {
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(200);
      resetGame();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
    return;
  }

  if (blockMoving && millis() - lastMove >= moveDelay) {
    blockPos += moveRight ? 1 : -1;

    if (blockPos <= 0) moveRight = true;
    if (blockPos >= WIDTH - blockWidth) moveRight = false;

    lastMove = millis();
    drawCurrentRow();  // only update current row
  }

  if (digitalRead(BUTTON_PIN) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_PIN) == LOW) {
      dropBlock();
      while (digitalRead(BUTTON_PIN) == LOW);
    }
  }
}
